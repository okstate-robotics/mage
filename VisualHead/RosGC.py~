#!/usr/bin/env python

"""
ModuleName: ROSGC.py
Author: Rakshit Allamraju

This module subscribes to the 'Sensor_data' and 'Navigation data' topics, generates the commands to guide the autonomous UAV and publishes 
to the topic 'Command_data'. 
"""

# python standard libraries
import os,sys
import socket
from numpy import loadtxt
from math import pi
from time import sleep
# Dependencies
import rospy
from tutorial.msg import command_data, sensor_data, navigation_data
from GClibs import *

# Global variables
global K_P, K_I, K_D, k_path, k_orbit, dt, R, k_i, gs, cs
global Ps, Pe
global c_out
global UAV_callsign


"""
Subscriber callback which initializes the guidance and control definitions and stores them as global . Call is only performed once to avoid reinitialization
of the definitions
"""
def UAV_init(Sensor):
	# Global variables	
	global K_P, K_I, K_D, k_path, k_orbit, dt, R, k_i, gs, cs
	global Ps, Pe
	global c_out

	# Read data from text file
	read = ['k_path','k_orbit','kp_phi','ki_phi','kd_phi','kp_t','ki_t','kd_t','kp_psi','ki_psi','kd_psi','kp_v','ki_v','kd_v','kp_alt','ki_alt','kd_alt','kp_x','ki_x','kd_x','dt','R']
	f = open('config.txt','r')

	data = {}
	counter = 0
	for line in f:
		line = line.strip()
		columns = line.split()
		value = columns[1]
		data[read[counter]] = float(value)
		counter += 1
	
	
	# Assign the Gain matrices	
	K_P = [data['kp_phi'],data['kp_t'],data['kp_psi'],data['kp_v'],data['kp_alt'],data['kp_x']]
	K_I = [data['ki_phi'],data['ki_t'],data['ki_psi'],data['ki_v'],data['ki_alt'],data['ki_x']]
	K_D = [data['kd_phi'],data['kd_t'],data['kd_psi'],data['kd_v'],data['kd_alt'],data['kd_x']]
	
	# Assign the path parameters
	k_path = data['k_path']
	k_orbit = data['k_orbit']

	# Timestep
	dt = data['dt']
	# Radius of path
	R = data['R']
	# Home
	k_i = array([ [Sensor.ki_x], [Sensor.ki_y], [Sensor.ki_z] ])

	gs = Guidance(k_path,k_orbit,k_i) # Guidance instance
	cs = Controller(K_P,K_I,K_D,dt) # Controller instance
	
	# Initial start and end waypoint
	Ps = array([[0],[0],[0],[45*pi/180]])
	Pe = array([[30000],[30000],[1000],[20*pi/180]])
	
	c_out = [0.0,0.0,0.0,0.0]


"""
Main callback function which generates the UAV commands. This function is infinitely called until the node shutdown is invoked.
"""

def UAV_Run(Sensor):	
	# Global variables	
	global K_P, K_I, K_D, k_path, k_orbit, dt, R, k_i, gs, cs
	global c_out
	
	# Position data
	p = array([ [Sensor.Pos_n],[Sensor.Pos_n],[Sensor.Pos_n] ])
	# Course data
	X = Sensor.course

	# Ps, Pe data obtained by invoking the Navigation_data_<UAV_callsign> topic
	#Ps = array([[0],[0],[0],[298*pi/180]])
	#Pe = array([[float(sys.argv[4])],[float(sys.argv[5])],[0],[180*pi/180]])
	
	
	# Create a subscriber instance to get data from Navigation_data topic	
	Sub_Topic_name = 'Navigation_data_'+UAV_callsign  ### MAKE SURE TO PASS UAV_callsign AS AN ARG TO THE FNC
	nav_sub=rospy.Subscriber(Sub_Topic_name, navigation_data, GetNav,queue_size=None) # Get data from Navigation_data topic
	#sleep(0.02) ### if new WP are not passed the problem might be here
	
	
	
	#check if new wps are generated
	gs.set_wp(Ps,Pe)		
	dub_out = gs.WPPDubins(p,R) # generate the guidance params
	if dub_out == None:
		pass
	else:
		REGIME = 1#int(fg_data[28])
		if REGIME == 1:
			if dub_out[0] == 1: # follow straight line
				g_out = gs.stline(dub_out[1],dub_out[2],p,X)			
			elif dub_out[0] == 2: # follow orbit
				g_out = gs.orbit(dub_out[3],p,X,dub_out[4],dub_out[5])
		elif REGIME == 0:
			if dub_out[0] == 1: # follow straight line
				g_out = gs.stline(dub_out[1],dub_out[2],p,X)	
				print 'St line'		
			elif dub_out[0] == 2: # follow orbit
				g_out = gs.orbit(dub_out[3],p,X,dub_out[4],dub_out[5])
				print 'orbit'
		h_c = g_out[0] #get the commanded height
		X_c = g_out[1] # get commanded course
		V_c = 60 # commanded velocity # 
			
		# Sensor data to pass to controller	
		sensor_in = [Sensor.Pos_n,Sensor.Pos_e,Sensor.Pos_d,Sensor.V_n_ms,Sensor.V_e_ms,Sensor.V_d_ms,Sensor.roll_deg,Sensor.pitch_deg,Sensor.yaw_deg,Sensor.p_body,Sensor.q_body,Sensor.r_body,Sensor.V_airspeed,Sensor.course]
		print Sensor.Pos_d, Sensor.course
		c_out = cs.control(sensor_in,h_c[0],X_c,V_c,state=REGIME) # get the controller commands to pass to FG
	# unregister from Navigation_data topic
	#nav_sub.unregister()
		
	
"""
Get the new initial and final waypoints
"""

def GetNav(Nav_data):
	global Ps, Pe
	Ps = array([ [Nav_data.Ps_x],[Nav_data.Ps_y],[Nav_data.Ps_z],[Nav_data.Ps_course] ])
	Pe = array([ [Nav_data.Pe_x],[Nav_data.Pe_y],[Nav_data.Pe_z],[Nav_data.Pe_course] ])


def GC_main(argv):
	global K_P, K_I, K_D, k_path, k_orbit, dt, R, k_i, gs, cs
	global Ps, Pe
	global c_out	
	global UAV_callsign

	if not isinstance(argv[3], str):
		print "Input Argument must be a string"
		sys.exit(-1)
	else:
		UAV_callsign = argv[3]
	
	# Initialize the GC node
	Node_name = 'ROSGC_'+UAV_callsign
	rospy.init_node(Node_name, anonymous=True)
	rate = rospy.Rate(100) # Publish at 100 hz

	# Create the publisher instance to push data to Command_data topic
	Pub_Topic_name = 'Command_data_'+UAV_callsign ### MAKE SURE TO PASS UAV_callsign AS ARG TO FNC
	uav_pub = rospy.Publisher(Pub_Topic_name,command_data,queue_size=10)
	Commands = command_data() # message type

	# Create the subscriber to get data from Sensor_data topic
	Sub_Topic_name = 'Sensor_data_'+UAV_callsign  ### MAKE SURE TO PASS UAV_callsign AS AN ARG TO THE FNC
	uav_sub=rospy.Subscriber(Sub_Topic_name, sensor_data, UAV_init,queue_size=30) # Get data from Sensor_data topic and initialize the definitions
	sleep(0.1) 
	uav_sub.unregister()
	Sub_Topic_name = 'Sensor_data_'+UAV_callsign  ### MAKE SURE TO PASS UAV_callsign AS AN ARG TO THE FNC
	uav_sub=rospy.Subscriber(Sub_Topic_name, sensor_data, UAV_Run,queue_size=30) # Get data from Sensor_data topic and execute the guidance & control loop

	
	while not rospy.is_shutdown():
		# Create the ROS message
		Commands.aileron = c_out[1]
		Commands.elevator = c_out[2]
		Commands.rudder = c_out[3]
		Commands.throttle = c_out[0]
		Commands.reached = int(gs.wp_complete)

		# roslog the commands
		# rospy.loginfo(Commands)
		# publish to Command_data topic
		uav_pub.publish(Commands)
		rate.sleep()

	print "Command publishing terminated..."
	#rospy.spin() # To prevent exiting main loop
	uav_sub.unregister()

	# Shutdown node
	err_str = "Shutting down node "+Node_name
	rospy.signal_shutdown(err_str)
	#print "Process shutdown"
	


	
